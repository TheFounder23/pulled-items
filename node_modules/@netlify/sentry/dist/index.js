var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { captureException, captureMessage, AWSLambda, configureScope, } from "@sentry/serverless";
import { basename } from "path";
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore TS2834
import fetch from "node-fetch";
export const NETLIFY_SENTRY_USAGE_ENDPOINT = `https://netlify-integration-sentry.netlify.app/.netlify/functions/analytics`;
export const getNetlifyConfig = (sentryConfig = {}) => {
    const netlifySentryConfigKeys = ["cronMonitoring"];
    const netlifyConfig = {};
    // Removes configuration not part of the Sentry SDK init before returning
    netlifySentryConfigKeys.forEach((key) => {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        netlifyConfig[key] = sentryConfig[key];
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        delete sentryConfig[key];
    });
    return netlifyConfig;
};
const getCronMonitoringCheckInRequestHeaders = () => {
    return {
        Authorization: `DSN ${process.env.SENTRY_DSN}`,
        "Content-Type": "application/json",
    };
};
export const startSentryCheckIn = (monitorId) => __awaiter(void 0, void 0, void 0, function* () {
    // Todo: replace with datadog monitoring
    console.log("Starting Sentry check in");
    const requestHeaders = getCronMonitoringCheckInRequestHeaders();
    yield fetch(`https://sentry.io/api/0/monitors/${monitorId}/checkins/`, {
        method: "POST",
        headers: requestHeaders,
        body: JSON.stringify({ status: "in_progress" }),
    });
});
export const completeSentryCheckIn = (monitorId) => __awaiter(void 0, void 0, void 0, function* () {
    const requestHeaders = getCronMonitoringCheckInRequestHeaders();
    yield fetch(`https://sentry.io/api/0/monitors/${monitorId}/checkins/latest/`, {
        method: "PUT",
        headers: requestHeaders,
        body: JSON.stringify({ status: "ok" }),
    });
    // Todo: replace with datadog monitoring
    console.log("Sentry check in completed");
});
const sendUsageMetrics = (cronMonitoring) => __awaiter(void 0, void 0, void 0, function* () {
    if (process.env.NODE_ENV === 'development')
        return;
    yield fetch(NETLIFY_SENTRY_USAGE_ENDPOINT, {
        method: "POST",
        body: JSON.stringify({
            siteId: process.env.SITE_ID,
            functionName: `netlify/functions/${basename(__filename)}`,
            isCronMonitoringEnabled: cronMonitoring === null || cronMonitoring === void 0 ? void 0 : cronMonitoring.enable,
        })
    });
});
export const withSentry = (handler, config) => {
    const sentry = {
        captureException,
        captureMessage,
    };
    const { cronMonitoring } = getNetlifyConfig(config === null || config === void 0 ? void 0 : config.sentry);
    const sentryConfigUserOverrides = (config === null || config === void 0 ? void 0 : config.sentry) || {};
    AWSLambda.init(Object.assign({ dsn: process.env.SENTRY_DSN, 
        // This value means that all events are sent to Sentry. While
        // this is not ideal for functions with higher numbers of invocations
        // it will ensure that those just getting started will see their events
        // be sent immediately to Sentry
        tracesSampleRate: 1.0 }, sentryConfigUserOverrides));
    return AWSLambda.wrapHandler((event, context) => __awaiter(void 0, void 0, void 0, function* () {
        yield sendUsageMetrics(cronMonitoring);
        if (cronMonitoring === null || cronMonitoring === void 0 ? void 0 : cronMonitoring.enable) {
            yield startSentryCheckIn(cronMonitoring.monitorId);
        }
        const functionName = `netlify/functions/${basename(__filename)}`;
        configureScope((scope) => scope.setTransactionName(functionName));
        if (cronMonitoring === null || cronMonitoring === void 0 ? void 0 : cronMonitoring.enable) {
            return handler(event, Object.assign(Object.assign({}, context), { sentry })).finally(() => __awaiter(void 0, void 0, void 0, function* () {
                yield completeSentryCheckIn(cronMonitoring.monitorId);
            }));
        }
        return handler(event, Object.assign(Object.assign({}, context), { sentry }));
    }));
};
