var {
  _optionalChain
} = require('@sentry/utils/cjs/buildPolyfills');

Object.defineProperty(exports, '__esModule', { value: true });

const Sentry = require('@sentry/node');
const utils = require('@sentry/utils');

/** Google Cloud Platform service requests tracking for GRPC APIs */
class GoogleCloudGrpc  {
  /**
   * @inheritDoc
   */
   static __initStatic() {this.id = 'GoogleCloudGrpc';}

  /**
   * @inheritDoc
   */
   __init() {this.name = GoogleCloudGrpc.id;}

   constructor(options = {}) {GoogleCloudGrpc.prototype.__init.call(this);
    this._optional = options.optional || false;
  }

  /**
   * @inheritDoc
   */
   setupOnce() {
    try {
      // eslint-disable-next-line @typescript-eslint/no-var-requires
      const gaxModule = require('google-gax');
      utils.fill(
        gaxModule.GrpcClient.prototype, // eslint-disable-line @typescript-eslint/no-unsafe-member-access
        'createStub',
        wrapCreateStub,
      );
    } catch (e) {
      if (!this._optional) {
        throw e;
      }
    }
  }
}GoogleCloudGrpc.__initStatic();

/** Returns a wrapped function that returns a stub with tracing enabled */
function wrapCreateStub(origCreate) {
  return async function ( ...args) {
    const servicePath = _optionalChain([args, 'access', _ => _[1], 'optionalAccess', _2 => _2.servicePath]);
    if (servicePath == null || servicePath == undefined) {
      return origCreate.apply(this, args);
    }
    const serviceIdentifier = identifyService(servicePath);
    const stub = await origCreate.apply(this, args);
    for (const methodName of Object.keys(Object.getPrototypeOf(stub))) {
      fillGrpcFunction(stub, serviceIdentifier, methodName);
    }
    return stub;
  };
}

/** Patches the function in grpc stub to enable tracing */
function fillGrpcFunction(stub, serviceIdentifier, methodName) {
  const funcObj = stub[methodName];
  if (typeof funcObj !== 'function') {
    return;
  }
  const callType =
    !funcObj.requestStream && !funcObj.responseStream
      ? 'unary call'
      : funcObj.requestStream && !funcObj.responseStream
      ? 'client stream'
      : !funcObj.requestStream && funcObj.responseStream
      ? 'server stream'
      : 'bidi stream';
  if (callType != 'unary call') {
    return;
  }
  utils.fill(
    stub,
    methodName,
    (orig) =>
      (...args) => {
        const ret = orig.apply(stub, args);
        if (typeof _optionalChain([ret, 'optionalAccess', _3 => _3.on]) !== 'function') {
          return ret;
        }
        let transaction;
        let span;
        const scope = Sentry.getCurrentHub().getScope();
        if (scope) {
          transaction = scope.getTransaction();
        }
        if (transaction) {
          span = transaction.startChild({
            description: `${callType} ${methodName}`,
            op: `grpc.${serviceIdentifier}`,
          });
        }
        ret.on('status', () => {
          if (span) {
            span.finish();
          }
        });
        return ret;
      },
  );
}

/** Identifies service by its address */
function identifyService(servicePath) {
  const match = servicePath.match(/^(\w+)\.googleapis.com$/);
  return match ? match[1] : servicePath;
}

exports.GoogleCloudGrpc = GoogleCloudGrpc;
//# sourceMappingURL=google-cloud-grpc.js.map
