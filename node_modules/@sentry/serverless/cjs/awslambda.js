Object.defineProperty(exports, '__esModule', { value: true });

const Sentry = require('@sentry/node');
const utils$1 = require('@sentry/utils');
const fs = require('fs');
const os = require('os');
const path = require('path');
const perf_hooks = require('perf_hooks');
const util = require('util');
const awsservices = require('./awsservices.js');
const utils = require('./utils.js');

const { isPromise } = util.types;

// https://www.npmjs.com/package/aws-lambda-consumer

const defaultIntegrations = [...Sentry.defaultIntegrations, new awsservices.AWSServices({ optional: true })];

/**
 * Changes a Dsn to point to the `relay` server running in the Lambda Extension.
 *
 * This is only used by the serverless integration for AWS Lambda.
 *
 * @param originalDsn The original Dsn of the customer.
 * @returns Dsn pointing to Lambda extension.
 */
function extensionRelayDSN(originalDsn) {
  if (originalDsn === undefined) {
    return undefined;
  }

  const dsn = utils$1.dsnFromString(originalDsn);
  dsn.host = 'localhost';
  dsn.port = '5333';
  dsn.protocol = 'http';

  return utils$1.dsnToString(dsn);
}

/**
 * @see {@link Sentry.init}
 */
function init(options = {}) {
  if (options.defaultIntegrations === undefined) {
    options.defaultIntegrations = defaultIntegrations;
  }

  options._metadata = options._metadata || {};
  options._metadata.sdk = {
    name: 'sentry.javascript.serverless',
    integrations: ['AWSLambda'],
    packages: [
      {
        name: 'npm:@sentry/serverless',
        version: Sentry.SDK_VERSION,
      },
    ],
    version: Sentry.SDK_VERSION,
  };

  // If invoked by the Sentry Lambda Layer point the SDK to the Lambda Extension (inside the layer) instead of the host
  // specified in the DSN
  if (options._invokedByLambdaLayer) {
    options.dsn = extensionRelayDSN(options.dsn);
  }

  Sentry.init(options);
  Sentry.addGlobalEventProcessor(utils.serverlessEventProcessor);
}

/** */
function tryRequire(taskRoot, subdir, mod) {
  const lambdaStylePath = path.resolve(taskRoot, subdir, mod);
  if (fs.existsSync(lambdaStylePath) || fs.existsSync(`${lambdaStylePath}.js`)) {
    // Lambda-style path
    return require(lambdaStylePath);
  }
  // Node-style path
  return require(require.resolve(mod, { paths: [taskRoot, subdir] }));
}

/** */
function isPromiseAllSettledResult(result) {
  return result.every(
    v =>
      Object.prototype.hasOwnProperty.call(v, 'status') &&
      (Object.prototype.hasOwnProperty.call(v, 'value') || Object.prototype.hasOwnProperty.call(v, 'reason')),
  );
}

/** */
function getRejectedReasons(results) {
  return results.reduce((rejected, result) => {
    if (result.status === 'rejected' && result.reason) rejected.push(result.reason);
    return rejected;
  }, []);
}

/** */
function tryPatchHandler(taskRoot, handlerPath) {

  const handlerDesc = path.basename(handlerPath);
  const match = handlerDesc.match(/^([^.]*)\.(.*)$/);
  if (!match) {
    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && utils$1.logger.error(`Bad handler ${handlerDesc}`);
    return;
  }

  const [, handlerMod, handlerName] = match;

  let obj;
  try {
    const handlerDir = handlerPath.substring(0, handlerPath.indexOf(handlerDesc));
    obj = tryRequire(taskRoot, handlerDir, handlerMod);
  } catch (e) {
    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && utils$1.logger.error(`Cannot require ${handlerPath} in ${taskRoot}`, e);
    return;
  }

  let mod;
  let functionName;
  handlerName.split('.').forEach(name => {
    mod = obj;
    obj = obj && (obj )[name];
    functionName = name;
  });
  if (!obj) {
    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && utils$1.logger.error(`${handlerPath} is undefined or not exported`);
    return;
  }
  if (typeof obj !== 'function') {
    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && utils$1.logger.error(`${handlerPath} is not a function`);
    return;
  }

  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  (mod )[functionName] = wrapHandler(obj);
}

/**
 * Tries to invoke context.getRemainingTimeInMillis if not available returns 0
 * Some environments use AWS lambda but don't support this function
 * @param context
 */
function tryGetRemainingTimeInMillis(context) {
  return typeof context.getRemainingTimeInMillis === 'function' ? context.getRemainingTimeInMillis() : 0;
}

/**
 * Adds additional information from the environment and AWS Context to the Sentry Scope.
 *
 * @param scope Scope that should be enhanced
 * @param context AWS Lambda context that will be used to extract some part of the data
 * @param startTime performance.now() when wrapHandler was invoked
 */
function enhanceScopeWithEnvironmentData(scope, context, startTime) {
  scope.setTransactionName(context.functionName);

  scope.setTag('server_name', process.env._AWS_XRAY_DAEMON_ADDRESS || process.env.SENTRY_NAME || os.hostname());
  scope.setTag('url', `awslambda:///${context.functionName}`);

  scope.setContext('aws.lambda', {
    aws_request_id: context.awsRequestId,
    function_name: context.functionName,
    function_version: context.functionVersion,
    invoked_function_arn: context.invokedFunctionArn,
    execution_duration_in_millis: perf_hooks.performance.now() - startTime,
    remaining_time_in_millis: tryGetRemainingTimeInMillis(context),
    'sys.argv': process.argv,
  });

  scope.setContext('aws.cloudwatch.logs', {
    log_group: context.logGroupName,
    log_stream: context.logStreamName,
    url: `https://console.aws.amazon.com/cloudwatch/home?region=${
      process.env.AWS_REGION
    }#logsV2:log-groups/log-group/${encodeURIComponent(context.logGroupName)}/log-events/${encodeURIComponent(
      context.logStreamName,
    )}?filterPattern="${context.awsRequestId}"`,
  });
}

/**
 * Wraps a lambda handler adding it error capture and tracing capabilities.
 *
 * @param handler Handler
 * @param options Options
 * @returns Handler
 */
function wrapHandler(
  handler,
  wrapOptions = {},
) {
  const START_TIME = perf_hooks.performance.now();
  const options = {
    flushTimeout: 2000,
    callbackWaitsForEmptyEventLoop: false,
    captureTimeoutWarning: true,
    timeoutWarningLimit: 500,
    captureAllSettledReasons: false,
    ...wrapOptions,
  };
  let timeoutWarningTimer;

  // AWSLambda is like Express. It makes a distinction about handlers based on its last argument
  // async (event) => async handler
  // async (event, context) => async handler
  // (event, context, callback) => sync handler
  // Nevertheless whatever option is chosen by user, we convert it to async handler.
  const asyncHandler =
    handler.length > 2
      ? (event, context) =>
          new Promise((resolve, reject) => {
            const rv = (handler )(event, context, (error, result) => {
              if (error === null || error === undefined) {
                resolve(result); // eslint-disable-line @typescript-eslint/no-non-null-assertion
              } else {
                reject(error);
              }
            }) ;

            // This should never happen, but still can if someone writes a handler as
            // `async (event, context, callback) => {}`
            if (isPromise(rv)) {
              void (rv ).then(resolve, reject);
            }
          })
      : (handler );

  return async (event, context) => {
    context.callbackWaitsForEmptyEventLoop = options.callbackWaitsForEmptyEventLoop;

    // In seconds. You cannot go any more granular than this in AWS Lambda.
    const configuredTimeout = Math.ceil(tryGetRemainingTimeInMillis(context) / 1000);
    const configuredTimeoutMinutes = Math.floor(configuredTimeout / 60);
    const configuredTimeoutSeconds = configuredTimeout % 60;

    const humanReadableTimeout =
      configuredTimeoutMinutes > 0
        ? `${configuredTimeoutMinutes}m${configuredTimeoutSeconds}s`
        : `${configuredTimeoutSeconds}s`;

    // When `callbackWaitsForEmptyEventLoop` is set to false, which it should when using `captureTimeoutWarning`,
    // we don't have a guarantee that this message will be delivered. Because of that, we don't flush it.
    if (options.captureTimeoutWarning) {
      const timeoutWarningDelay = tryGetRemainingTimeInMillis(context) - options.timeoutWarningLimit;

      timeoutWarningTimer = setTimeout(() => {
        Sentry.withScope(scope => {
          scope.setTag('timeout', humanReadableTimeout);
          Sentry.captureMessage(`Possible function timeout: ${context.functionName}`, 'warning');
        });
      }, timeoutWarningDelay) ;
    }

    // Applying `sentry-trace` to context
    let traceparentData;
    const eventWithHeaders = event ;
    if (eventWithHeaders.headers && utils$1.isString(eventWithHeaders.headers['sentry-trace'])) {
      traceparentData = utils$1.extractTraceparentData(eventWithHeaders.headers['sentry-trace']);
    }

    const baggageHeader = eventWithHeaders.headers && eventWithHeaders.headers.baggage;
    const dynamicSamplingContext = utils$1.baggageHeaderToDynamicSamplingContext(baggageHeader);

    const hub = Sentry.getCurrentHub();

    const transaction = hub.startTransaction({
      name: context.functionName,
      op: 'function.aws.lambda',
      ...traceparentData,
      metadata: {
        dynamicSamplingContext: traceparentData && !dynamicSamplingContext ? {} : dynamicSamplingContext,
        source: 'component',
      },
    });

    const scope = hub.pushScope();
    let rv;
    try {
      enhanceScopeWithEnvironmentData(scope, context, START_TIME);
      // We put the transaction on the scope so users can attach children to it
      scope.setSpan(transaction);
      rv = await asyncHandler(event, context);

      // We manage lambdas that use Promise.allSettled by capturing the errors of failed promises
      if (options.captureAllSettledReasons && Array.isArray(rv) && isPromiseAllSettledResult(rv)) {
        const reasons = getRejectedReasons(rv);
        reasons.forEach(exception => {
          Sentry.captureException(exception);
        });
      }
    } catch (e) {
      Sentry.captureException(e);
      throw e;
    } finally {
      clearTimeout(timeoutWarningTimer);
      transaction.finish();
      hub.popScope();
      await Sentry.flush(options.flushTimeout).catch(e => {
        (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && utils$1.logger.error(e);
      });
    }
    return rv;
  };
}

exports.defaultIntegrations = defaultIntegrations;
exports.init = init;
exports.tryPatchHandler = tryPatchHandler;
exports.wrapHandler = wrapHandler;
for (const k in Sentry) {
  if (k !== 'default' && !exports.hasOwnProperty(k)) exports[k] = Sentry[k];
}
//# sourceMappingURL=awslambda.js.map
