import { _optionalChain } from '@sentry/utils/esm/buildPolyfills';
import { getCurrentHub, flush, captureException } from '@sentry/node';
import { stripUrlQueryAndFragment, isString, extractTraceparentData, baggageHeaderToDynamicSamplingContext, logger, isThenable } from '@sentry/utils';
import { proxyFunction, domainify } from '../utils.js';

// TODO (v8 / #5257): Remove this whole old/new business and just use the new stuff

/**
 * Wraps an HTTP function handler adding it error capture and tracing capabilities.
 *
 * @param fn HTTP Handler
 * @param options Options
 * @returns HTTP handler
 */
function wrapHttpFunction(
  fn,
  wrapOptions = {},
) {
  const wrap = (f) => domainify(_wrapHttpFunction(f, wrapOptions));

  let overrides;

  // Functions emulator from firebase-tools has a hack-ish workaround that saves the actual function
  // passed to `onRequest(...)` and in fact runs it so we need to wrap it too.
  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access
  const emulatorFunc = (fn ).__emulator_func ;
  if (emulatorFunc) {
    overrides = { __emulator_func: proxyFunction(emulatorFunc, wrap) };
  }
  return proxyFunction(fn, wrap, overrides);
}

/** */
function _wrapHttpFunction(fn, wrapOptions = {}) {
  // TODO (v8 / #5257): Switch to using `addRequestDataToEventOptions`
  // eslint-disable-next-line deprecation/deprecation
  const { parseRequestOptions } = wrapOptions ;

  const options = {
    flushTimeout: 2000,
    // TODO (v8 / xxx): Remove this line, since `addRequestDataToEventOptions` will be included in the spread of `wrapOptions`
    addRequestDataToEventOptions: parseRequestOptions ? { include: parseRequestOptions } : {},
    ...wrapOptions,
  };
  return (req, res) => {
    const reqMethod = (req.method || '').toUpperCase();
    const reqUrl = stripUrlQueryAndFragment(req.originalUrl || req.url || '');

    // Applying `sentry-trace` to context
    let traceparentData;
    const reqWithHeaders = req ;
    if (reqWithHeaders.headers && isString(reqWithHeaders.headers['sentry-trace'])) {
      traceparentData = extractTraceparentData(reqWithHeaders.headers['sentry-trace']);
    }

    const baggageHeader = _optionalChain([reqWithHeaders, 'access', _ => _.headers, 'optionalAccess', _2 => _2.baggage]);

    const dynamicSamplingContext = baggageHeaderToDynamicSamplingContext(baggageHeader);

    const hub = getCurrentHub();

    const transaction = hub.startTransaction({
      name: `${reqMethod} ${reqUrl}`,
      op: 'function.gcp.http',
      ...traceparentData,
      metadata: {
        dynamicSamplingContext: traceparentData && !dynamicSamplingContext ? {} : dynamicSamplingContext,
        source: 'route',
      },
    });

    // getCurrentHub() is expected to use current active domain as a carrier
    // since functions-framework creates a domain for each incoming request.
    // So adding of event processors every time should not lead to memory bloat.
    hub.configureScope(scope => {
      scope.setSDKProcessingMetadata({
        request: req,
        requestDataOptionsFromGCPWrapper: options.addRequestDataToEventOptions,
      });
      // We put the transaction on the scope so users can attach children to it
      scope.setSpan(transaction);
    });

    // We also set __sentry_transaction on the response so people can grab the transaction there to add
    // spans to it later.
    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access
    (res ).__sentry_transaction = transaction;

    // eslint-disable-next-line @typescript-eslint/unbound-method
    const _end = res.end;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    res.end = function (chunk, encoding, cb) {
      transaction.setHttpStatus(res.statusCode);
      transaction.finish();

      void flush(options.flushTimeout)
        .then(null, e => {
          (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.error(e);
        })
        .then(() => {
          _end.call(this, chunk, encoding, cb);
        });
    };

    let fnResult;
    try {
      fnResult = fn(req, res);
    } catch (err) {
      captureException(err);
      throw err;
    }

    if (isThenable(fnResult)) {
      fnResult.then(null, err => {
        captureException(err);
        throw err;
      });
    }

    return fnResult;
  };
}

export { wrapHttpFunction };
//# sourceMappingURL=http.js.map
