{"version":3,"file":"utils.js","sources":["../../../src/utils.ts"],"sourcesContent":["import type { Event } from '@sentry/node';\nimport { addExceptionMechanism } from '@sentry/utils';\nimport * as domain from 'domain';\n\n/**\n * Event processor that will override SDK details to point to the serverless SDK instead of Node,\n * as well as set correct mechanism type, which should be set to `handled: false`.\n * We do it like this so that we don't introduce any side-effects in this module, which makes it tree-shakeable.\n * @param event Event\n * @param integration Name of the serverless integration ('AWSLambda', 'GCPFunction', etc)\n */\nexport function serverlessEventProcessor(event: Event): Event {\n  addExceptionMechanism(event, {\n    handled: false,\n  });\n\n  return event;\n}\n\n/**\n * @returns Current active domain with a correct type.\n */\nexport function getActiveDomain(): domain.Domain | null {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access\n  return (domain as any).active as domain.Domain | null;\n}\n\n/**\n * @param fn function to run\n * @returns function which runs in the newly created domain or in the existing one\n */\nexport function domainify<A extends unknown[], R>(fn: (...args: A) => R): (...args: A) => R | void {\n  return (...args) => {\n    if (getActiveDomain()) {\n      return fn(...args);\n    }\n    const dom = domain.create();\n    return dom.run(() => fn(...args));\n  };\n}\n\n/**\n * @param source function to be wrapped\n * @param wrap wrapping function that takes source and returns a wrapper\n * @param overrides properties to override in the source\n * @returns wrapped function\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function proxyFunction<A extends any[], R, F extends (...args: A) => R>(\n  source: F,\n  wrap: (source: F) => F,\n  overrides?: Record<PropertyKey, unknown>,\n): F {\n  const wrapper = wrap(source);\n  const handler: ProxyHandler<F> = {\n    apply: <T>(_target: F, thisArg: T, args: A) => {\n      return wrapper.apply(thisArg, args);\n    },\n  };\n\n  if (overrides) {\n    handler.get = (target, prop) => {\n      if (Object.prototype.hasOwnProperty.call(overrides, prop)) {\n        return overrides[prop as string];\n      }\n      return (target as Record<PropertyKey, unknown>)[prop as string];\n    };\n  }\n\n  return new Proxy(source, handler);\n}\n"],"names":[],"mappings":";;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAA,wBAAA,CAAA,KAAA,EAAA;AACA,EAAA,qBAAA,CAAA,KAAA,EAAA;AACA,IAAA,OAAA,EAAA,KAAA;AACA,GAAA,CAAA,CAAA;AACA;AACA,EAAA,OAAA,KAAA,CAAA;AACA,CAAA;AACA;AACA;AACA;AACA;AACA,SAAA,eAAA,GAAA;AACA;AACA,EAAA,OAAA,CAAA,MAAA,GAAA,MAAA,EAAA;AACA,CAAA;AACA;AACA;AACA;AACA;AACA;AACA,SAAA,SAAA,CAAA,EAAA,EAAA;AACA,EAAA,OAAA,CAAA,GAAA,IAAA,KAAA;AACA,IAAA,IAAA,eAAA,EAAA,EAAA;AACA,MAAA,OAAA,EAAA,CAAA,GAAA,IAAA,CAAA,CAAA;AACA,KAAA;AACA,IAAA,MAAA,GAAA,GAAA,MAAA,CAAA,MAAA,EAAA,CAAA;AACA,IAAA,OAAA,GAAA,CAAA,GAAA,CAAA,MAAA,EAAA,CAAA,GAAA,IAAA,CAAA,CAAA,CAAA;AACA,GAAA,CAAA;AACA,CAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAA,aAAA;AACA,EAAA,MAAA;AACA,EAAA,IAAA;AACA,EAAA,SAAA;AACA,EAAA;AACA,EAAA,MAAA,OAAA,GAAA,IAAA,CAAA,MAAA,CAAA,CAAA;AACA,EAAA,MAAA,OAAA,GAAA;AACA,IAAA,KAAA,EAAA,CAAA,OAAA,EAAA,OAAA,EAAA,IAAA,KAAA;AACA,MAAA,OAAA,OAAA,CAAA,KAAA,CAAA,OAAA,EAAA,IAAA,CAAA,CAAA;AACA,KAAA;AACA,GAAA,CAAA;AACA;AACA,EAAA,IAAA,SAAA,EAAA;AACA,IAAA,OAAA,CAAA,GAAA,GAAA,CAAA,MAAA,EAAA,IAAA,KAAA;AACA,MAAA,IAAA,MAAA,CAAA,SAAA,CAAA,cAAA,CAAA,IAAA,CAAA,SAAA,EAAA,IAAA,CAAA,EAAA;AACA,QAAA,OAAA,SAAA,CAAA,IAAA,EAAA,CAAA;AACA,OAAA;AACA,MAAA,OAAA,CAAA,MAAA,GAAA,IAAA,EAAA,CAAA;AACA,KAAA,CAAA;AACA,GAAA;AACA;AACA,EAAA,OAAA,IAAA,KAAA,CAAA,MAAA,EAAA,OAAA,CAAA,CAAA;AACA;;;;"}